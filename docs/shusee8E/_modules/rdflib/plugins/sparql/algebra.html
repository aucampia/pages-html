
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>rdflib.plugins.sparql.algebra &#8212; rdflib 6.2.0-alpha documentation</title>

<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/>


    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/rtd.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../../../../../_static/searchtools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/RDFlib.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">rdflib 6.2.0-alpha documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rdflib.plugins.sparql.algebra</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for rdflib.plugins.sparql.algebra</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Converting the &#39;parse-tree&#39; output of pyparsing to a SPARQL Algebra expression</span>

<span class="sd">http://www.w3.org/TR/sparql11-query/#sparqlQuery</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>

<span class="kn">from</span> <span class="nn">rdflib</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">,</span> <span class="n">BNode</span>

<span class="kn">from</span> <span class="nn">rdflib.plugins.sparql.sparql</span> <span class="kn">import</span> <span class="n">Prologue</span><span class="p">,</span> <span class="n">Query</span><span class="p">,</span> <span class="n">Update</span>
<span class="kn">from</span> <span class="nn">rdflib.plugins.sparql.parserutils</span> <span class="kn">import</span> <span class="n">CompValue</span><span class="p">,</span> <span class="n">Expr</span>
<span class="kn">from</span> <span class="nn">rdflib.plugins.sparql.operators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">and_</span><span class="p">,</span>
    <span class="n">TrueFilter</span><span class="p">,</span>
    <span class="n">simplify</span> <span class="k">as</span> <span class="n">simplifyFilters</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">rdflib.paths</span> <span class="kn">import</span> <span class="n">InvPath</span><span class="p">,</span> <span class="n">AlternativePath</span><span class="p">,</span> <span class="n">SequencePath</span><span class="p">,</span> <span class="n">MulPath</span><span class="p">,</span> <span class="n">NegatedPath</span>

<span class="kn">from</span> <span class="nn">pyparsing</span> <span class="kn">import</span> <span class="n">ParseResults</span>


<span class="c1"># ---------------------------</span>
<span class="c1"># Some convenience methods</span>
<span class="kn">from</span> <span class="nn">rdflib.term</span> <span class="kn">import</span> <span class="n">Identifier</span>


<div class="viewcode-block" id="OrderBy"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.OrderBy">[docs]</a><span class="k">def</span> <span class="nf">OrderBy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;OrderBy&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="ToMultiSet"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.ToMultiSet">[docs]</a><span class="k">def</span> <span class="nf">ToMultiSet</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;ToMultiSet&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="Union"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Union">[docs]</a><span class="k">def</span> <span class="nf">Union</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Union&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Join"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Join">[docs]</a><span class="k">def</span> <span class="nf">Join</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Join&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Minus"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Minus">[docs]</a><span class="k">def</span> <span class="nf">Minus</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Minus&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Graph">[docs]</a><span class="k">def</span> <span class="nf">Graph</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Graph&quot;</span><span class="p">,</span> <span class="n">term</span><span class="o">=</span><span class="n">term</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span></div>


<div class="viewcode-block" id="BGP"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.BGP">[docs]</a><span class="k">def</span> <span class="nf">BGP</span><span class="p">(</span><span class="n">triples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;BGP&quot;</span><span class="p">,</span> <span class="n">triples</span><span class="o">=</span><span class="n">triples</span> <span class="ow">or</span> <span class="p">[])</span></div>


<div class="viewcode-block" id="LeftJoin"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.LeftJoin">[docs]</a><span class="k">def</span> <span class="nf">LeftJoin</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;LeftJoin&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">p2</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Filter"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Filter">[docs]</a><span class="k">def</span> <span class="nf">Filter</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Filter&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="Extend"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Extend">[docs]</a><span class="k">def</span> <span class="nf">Extend</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Extend&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">)</span></div>


<div class="viewcode-block" id="Values"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Values">[docs]</a><span class="k">def</span> <span class="nf">Values</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="Project"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Project">[docs]</a><span class="k">def</span> <span class="nf">Project</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PV</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">PV</span><span class="o">=</span><span class="n">PV</span><span class="p">)</span></div>


<div class="viewcode-block" id="Group"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.Group">[docs]</a><span class="k">def</span> <span class="nf">Group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Group&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_knownTerms</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">varsknown</span><span class="p">,</span> <span class="n">varscount</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">x</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">triple</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">varsknown</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">BNode</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="p">),</span>
        <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">varscount</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">triple</span><span class="p">),</span>
        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Literal</span><span class="p">),</span>
    <span class="p">)</span>


<div class="viewcode-block" id="reorderTriples"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.reorderTriples">[docs]</a><span class="k">def</span> <span class="nf">reorderTriples</span><span class="p">(</span><span class="n">l_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder triple patterns so that we execute the</span>
<span class="sd">    ones with most bindings first</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_addvar</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">varsknown</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">BNode</span><span class="p">)):</span>
            <span class="n">varsknown</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="n">l_</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l_</span><span class="p">]</span>
    <span class="n">varsknown</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">varscount</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">l_</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">BNode</span><span class="p">)):</span>
                <span class="n">varscount</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Done in steps, sort by number of bound terms</span>
    <span class="c1"># the top block of patterns with the most bound terms is kept</span>
    <span class="c1"># the rest is resorted based on the vars bound after the first</span>
    <span class="c1"># block is evaluated</span>

    <span class="c1"># we sort by decorate/undecorate, since we need the value of the sort keys</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_</span><span class="p">):</span>
        <span class="n">l_</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">_knownTerms</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">varsknown</span><span class="p">,</span> <span class="n">varscount</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l_</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">l_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># top block has this many terms bound</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_</span><span class="p">)</span> <span class="ow">and</span> <span class="n">l_</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">l_</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">_addvar</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">varsknown</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l_</span><span class="p">]</span></div>


<div class="viewcode-block" id="triples"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.triples">[docs]</a><span class="k">def</span> <span class="nf">triples</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;these aint triples&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reorderTriples</span><span class="p">((</span><span class="n">l</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span></div>


<div class="viewcode-block" id="translatePName"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translatePName">[docs]</a><span class="k">def</span> <span class="nf">translatePName</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prologue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand prefixed/relative URIs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;pname&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prologue</span><span class="o">.</span><span class="n">absolutize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span>
                <span class="n">p</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">lang</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">prologue</span><span class="o">.</span><span class="n">absolutize</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">prologue</span><span class="o">.</span><span class="n">absolutize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="translatePath"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translatePath">[docs]</a><span class="k">def</span> <span class="nf">translatePath</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate PropertyPath expressions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PathAlternative&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AlternativePath</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PathSequence&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SequencePath</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PathElt&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">mod</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">part</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Denkfehler!&quot;</span><span class="p">)</span>

                    <span class="k">return</span> <span class="n">MulPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">mod</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">MulPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">mod</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PathEltOrInverse&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Denkfehler!&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">InvPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">InvPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PathNegatedPropertySet&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">NegatedPath</span><span class="p">(</span><span class="n">AlternativePath</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NegatedPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">part</span><span class="p">)</span></div>


<div class="viewcode-block" id="translateExists"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateExists">[docs]</a><span class="k">def</span> <span class="nf">translateExists</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate the graph pattern used by EXISTS and NOT EXISTS</span>
<span class="sd">    http://www.w3.org/TR/sparql11-query/#sparqlCollectFilters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_c</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Builtin_EXISTS&quot;</span><span class="p">,</span> <span class="s2">&quot;Builtin_NOTEXISTS&quot;</span><span class="p">):</span>
                <span class="n">n</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Filter&quot;</span><span class="p">:</span>
                    <span class="c1"># filters inside (NOT) EXISTS can see vars bound outside</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">no_isolated_scope</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="n">_c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">e</span></div>


<div class="viewcode-block" id="collectAndRemoveFilters"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.collectAndRemoveFilters">[docs]</a><span class="k">def</span> <span class="nf">collectAndRemoveFilters</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    FILTER expressions apply to the whole group graph pattern in which</span>
<span class="sd">    they appear.</span>

<span class="sd">    http://www.w3.org/TR/sparql11-query/#sparqlCollectFilters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Filter&quot;</span><span class="p">:</span>
            <span class="n">filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translateExists</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">expr</span><span class="p">))</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">filters</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">filters</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="translateGroupOrUnionGraphPattern"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateGroupOrUnionGraphPattern">[docs]</a><span class="k">def</span> <span class="nf">translateGroupOrUnionGraphPattern</span><span class="p">(</span><span class="n">graphPattern</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphPattern</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">g</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="translateGraphGraphPattern"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateGraphGraphPattern">[docs]</a><span class="k">def</span> <span class="nf">translateGraphGraphPattern</span><span class="p">(</span><span class="n">graphPattern</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="n">graphPattern</span><span class="o">.</span><span class="n">term</span><span class="p">,</span> <span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">graphPattern</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span></div>


<div class="viewcode-block" id="translateInlineData"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateInlineData">[docs]</a><span class="k">def</span> <span class="nf">translateInlineData</span><span class="p">(</span><span class="n">graphPattern</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ToMultiSet</span><span class="p">(</span><span class="n">translateValues</span><span class="p">(</span><span class="n">graphPattern</span><span class="p">))</span></div>


<div class="viewcode-block" id="translateGroupGraphPattern"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateGroupGraphPattern">[docs]</a><span class="k">def</span> <span class="nf">translateGroupGraphPattern</span><span class="p">(</span><span class="n">graphPattern</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    http://www.w3.org/TR/sparql11-query/#convertGraphPattern</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">graphPattern</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;SubSelect&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ToMultiSet</span><span class="p">(</span><span class="n">translate</span><span class="p">(</span><span class="n">graphPattern</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">graphPattern</span><span class="o">.</span><span class="n">part</span><span class="p">:</span>
        <span class="n">graphPattern</span><span class="o">.</span><span class="n">part</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># empty { }</span>

    <span class="n">filters</span> <span class="o">=</span> <span class="n">collectAndRemoveFilters</span><span class="p">(</span><span class="n">graphPattern</span><span class="o">.</span><span class="n">part</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">graphPattern</span><span class="o">.</span><span class="n">part</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;TriplesBlock&quot;</span><span class="p">:</span>
            <span class="c1"># merge adjacent TripleBlocks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">g</span> <span class="ow">and</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;BGP&quot;</span><span class="p">):</span>
                <span class="n">g</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BGP</span><span class="p">())</span>
            <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;triples&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">triples</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">triples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">BGP</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;OptionalGraphPattern&quot;</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Filter&quot;</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">LeftJoin</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">LeftJoin</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">TrueFilter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;MinusGraphPattern&quot;</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Minus</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;GroupOrUnionGraphPattern&quot;</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">translateGroupOrUnionGraphPattern</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;GraphGraphPattern&quot;</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">translateGraphGraphPattern</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;InlineData&quot;</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">translateInlineData</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ServiceGraphPattern&quot;</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;BGP&quot;</span><span class="p">,</span> <span class="s2">&quot;Extend&quot;</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Bind&quot;</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">Extend</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Unknown part in GroupGraphPattern: </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">filters</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Filter</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">G</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="StopTraversal"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.StopTraversal">[docs]</a><span class="k">class</span> <span class="nc">StopTraversal</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<div class="viewcode-block" id="StopTraversal.__init__"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.StopTraversal.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rv</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span></div></div>


<span class="k">def</span> <span class="nf">_traverse</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">visitPre</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Traverse a parse-tree, visit each node</span>

<span class="sd">    if visit functions return a value, replace current node</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_e</span> <span class="o">=</span> <span class="n">visitPre</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_e</span>

    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">visitPre</span><span class="p">,</span> <span class="n">visitPost</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_traverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">visitPre</span><span class="p">,</span> <span class="n">visitPost</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="p">])</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">e</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">visitPre</span><span class="p">,</span> <span class="n">visitPost</span><span class="p">)</span>

    <span class="n">_e</span> <span class="o">=</span> <span class="n">visitPost</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_e</span>

    <span class="k">return</span> <span class="n">e</span>


<span class="k">def</span> <span class="nf">_traverseAgg</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">visitor</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Traverse a parse-tree, visit each node</span>

<span class="sd">    if visit functions return a value, replace current node</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">_traverseAgg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_traverseAgg</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">visitor</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">visitor</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<div class="viewcode-block" id="traverse"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.traverse">[docs]</a><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">visitPre</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Traverse tree, visit each node with visit function</span>
<span class="sd">    visit function may raise StopTraversal to stop traversal</span>
<span class="sd">    if complete!=None, it is returned on complete traversal,</span>
<span class="sd">    otherwise the transformed tree is returned</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">visitPre</span><span class="p">,</span> <span class="n">visitPost</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">complete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">complete</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">except</span> <span class="n">StopTraversal</span> <span class="k">as</span> <span class="n">st</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">rv</span></div>


<span class="k">def</span> <span class="nf">_hasAggregate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Traverse parse(sub)Tree</span>
<span class="sd">    return true if any aggregates are used</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Aggregate_&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">StopTraversal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_aggs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect Aggregates in A</span>
<span class="sd">    replaces aggregates with variable references</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: nested Aggregates?</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Aggregate_&quot;</span><span class="p">):</span>
        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">aggvar</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;__agg_</span><span class="si">%d</span><span class="s2">__&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="n">e</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggvar</span>
        <span class="k">return</span> <span class="n">aggvar</span>


<span class="k">def</span> <span class="nf">_findVars</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all variables in a tree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Bind&quot;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span>  <span class="c1"># stop recursion and finding vars in the expr</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;SubSelect&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">var</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">evar</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">projection</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_addVars</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find which variables may be bound by this part of the query</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;RelationalExpression&quot;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="s2">&quot;_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Extend&quot;</span><span class="p">:</span>
            <span class="c1"># vars only used in the expr for a bind should not be included</span>
            <span class="n">x</span><span class="p">[</span><span class="s2">&quot;_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span>
                <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">part</span> <span class="o">!=</span> <span class="s2">&quot;expr&quot;</span><span class="p">],</span>
                <span class="nb">set</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="s2">&quot;_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>

            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;SubSelect&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">var</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">evar</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">projection</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">s</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;_vars&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each unaggregated variable V in expr</span>
<span class="sd">    Replace V with Sample(V)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Aggregate_&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span>  <span class="c1"># do not replace vars in aggregates</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Aggregate_Sample&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_simplifyFilters</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">simplifyFilters</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>


<div class="viewcode-block" id="translateAggregates"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateAggregates">[docs]</a><span class="k">def</span> <span class="nf">translateAggregates</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># collect/replace aggs in :</span>
    <span class="c1">#    select expr as ?var</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">evar</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_sample</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">evar</span><span class="p">))</span>
                <span class="n">v</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_aggs</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">))</span>

    <span class="c1"># having clause</span>
    <span class="k">if</span> <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">having</span><span class="p">,</span> <span class="n">_hasAggregate</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">q</span><span class="o">.</span><span class="n">having</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">having</span><span class="p">,</span> <span class="n">_sample</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">having</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_aggs</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">))</span>

    <span class="c1"># order by</span>
    <span class="k">if</span> <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">orderby</span><span class="p">,</span> <span class="n">_hasAggregate</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">q</span><span class="o">.</span><span class="n">orderby</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">orderby</span><span class="p">,</span> <span class="n">_sample</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">orderby</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_aggs</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">))</span>

    <span class="c1"># sample all other select vars</span>
    <span class="c1"># TODO: only allowed for vars in group-by?</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;__agg_</span><span class="si">%d</span><span class="s2">__&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Aggregate_Sample&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">rv</span><span class="p">))</span>
                <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">rv</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;AggregateJoin&quot;</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">),</span> <span class="n">E</span></div>


<div class="viewcode-block" id="translateValues"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateValues">[docs]</a><span class="k">def</span> <span class="nf">translateValues</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="c1"># if len(v.var)!=len(v.value):</span>
    <span class="c1">#     raise Exception(&quot;Unmatched vars and values in ValueClause: &quot;+str(v))</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">val</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">vals</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">Values</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="translate"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translate">[docs]</a><span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    http://www.w3.org/TR/sparql11-query/#convertSolMod</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_traverse</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">_simplifyFilters</span><span class="p">)</span>

    <span class="n">q</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="n">translatePath</span><span class="p">)</span>

    <span class="c1"># TODO: Var scope test</span>
    <span class="n">VS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_findVars</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">VS</span><span class="p">))</span>

    <span class="c1"># all query types have a where part</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>

    <span class="n">aggregate</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">groupby</span><span class="p">:</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># convert &quot;GROUP BY (?expr as ?var)&quot; to an Extend</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">groupby</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;GroupAs&quot;</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">Extend</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">var</span>
            <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="n">M</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">conditions</span><span class="p">)</span>
        <span class="n">aggregate</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">having</span><span class="p">,</span> <span class="n">_hasAggregate</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">traverse</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">orderby</span><span class="p">,</span> <span class="n">_hasAggregate</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">_hasAggregate</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span> <span class="ow">or</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">evar</span>
        <span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># if any aggregate is used, implicit group by</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
        <span class="n">aggregate</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">aggregate</span><span class="p">:</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">translateAggregates</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># HAVING</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">having</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">Filter</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">having</span><span class="o">.</span><span class="n">condition</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>

    <span class="c1"># VALUES</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">valuesClause</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">ToMultiSet</span><span class="p">(</span><span class="n">translateValues</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">valuesClause</span><span class="p">)))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
        <span class="c1"># select *</span>
        <span class="n">PV</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">VS</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">PV</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">projection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PV</span><span class="p">:</span>
                    <span class="n">PV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">evar</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PV</span><span class="p">:</span>
                    <span class="n">PV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">evar</span><span class="p">)</span>

                <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">evar</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;I expected a var or evar here!&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">Extend</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="c1"># ORDER BY</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">orderby</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">OrderBy</span><span class="p">(</span>
            <span class="n">M</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;OrderCondition&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">orderby</span><span class="o">.</span><span class="n">condition</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="c1"># PROJECT</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">Project</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">PV</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">modifier</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">modifier</span> <span class="o">==</span> <span class="s2">&quot;DISTINCT&quot;</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Distinct&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">q</span><span class="o">.</span><span class="n">modifier</span> <span class="o">==</span> <span class="s2">&quot;REDUCED&quot;</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Reduced&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">limitoffset</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">limitoffset</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">limitoffset</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">limitoffset</span><span class="o">.</span><span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">CompValue</span><span class="p">(</span>
                <span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="n">limitoffset</span><span class="o">.</span><span class="n">limit</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">CompValue</span><span class="p">(</span><span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">PV</span></div>


<div class="viewcode-block" id="simplify"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.simplify">[docs]</a><span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove joins to empty BGPs&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Join&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;BGP&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">triples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">p2</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;BGP&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">triples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">p1</span>
        <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;BGP&quot;</span><span class="p">:</span>
            <span class="n">n</span><span class="p">[</span><span class="s2">&quot;triples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reorderTriples</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">triples</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span></div>


<div class="viewcode-block" id="analyse"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.analyse">[docs]</a><span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Some things can be lazily joined.</span>
<span class="sd">    This propegates whether they can up the tree</span>
<span class="sd">    and sets lazy flags for all joins</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Join&quot;</span><span class="p">:</span>
            <span class="n">n</span><span class="p">[</span><span class="s2">&quot;lazy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="s2">&quot;Distinct&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="translatePrologue"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translatePrologue">[docs]</a><span class="k">def</span> <span class="nf">translatePrologue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">initNs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prologue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">prologue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prologue</span> <span class="o">=</span> <span class="n">Prologue</span><span class="p">()</span>
        <span class="n">prologue</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">base</span><span class="p">:</span>
        <span class="n">prologue</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
    <span class="k">if</span> <span class="n">initNs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">initNs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">prologue</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Base&quot;</span><span class="p">:</span>
            <span class="n">prologue</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">iri</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PrefixDecl&quot;</span><span class="p">:</span>
            <span class="n">prologue</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">prologue</span><span class="o">.</span><span class="n">absolutize</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">iri</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">prologue</span></div>


<div class="viewcode-block" id="translateQuads"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateQuads">[docs]</a><span class="k">def</span> <span class="nf">translateQuads</span><span class="p">(</span><span class="n">quads</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">quads</span><span class="o">.</span><span class="n">triples</span><span class="p">:</span>
        <span class="n">alltriples</span> <span class="o">=</span> <span class="n">triples</span><span class="p">(</span><span class="n">quads</span><span class="o">.</span><span class="n">triples</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alltriples</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">allquads</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">quads</span><span class="o">.</span><span class="n">quadsNotTriples</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quads</span><span class="o">.</span><span class="n">quadsNotTriples</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">triples</span><span class="p">:</span>
                <span class="n">allquads</span><span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">term</span><span class="p">]</span> <span class="o">+=</span> <span class="n">triples</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">triples</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">alltriples</span><span class="p">,</span> <span class="n">allquads</span></div>


<div class="viewcode-block" id="translateUpdate1"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateUpdate1">[docs]</a><span class="k">def</span> <span class="nf">translateUpdate1</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">prologue</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Load&quot;</span><span class="p">,</span> <span class="s2">&quot;Clear&quot;</span><span class="p">,</span> <span class="s2">&quot;Drop&quot;</span><span class="p">,</span> <span class="s2">&quot;Create&quot;</span><span class="p">):</span>
        <span class="k">pass</span>  <span class="c1"># no translation needed</span>
    <span class="k">elif</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Add&quot;</span><span class="p">,</span> <span class="s2">&quot;Move&quot;</span><span class="p">,</span> <span class="s2">&quot;Copy&quot;</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;InsertData&quot;</span><span class="p">,</span> <span class="s2">&quot;DeleteData&quot;</span><span class="p">,</span> <span class="s2">&quot;DeleteWhere&quot;</span><span class="p">):</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">translateQuads</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">quads</span><span class="p">)</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;quads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;triples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;DeleteWhere&quot;</span><span class="p">,</span> <span class="s2">&quot;DeleteData&quot;</span><span class="p">):</span>
            <span class="k">pass</span>  <span class="c1"># TODO: check for bnodes in triples</span>
    <span class="k">elif</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Modify&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">delete</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">delete</span><span class="p">[</span><span class="s2">&quot;triples&quot;</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">delete</span><span class="p">[</span><span class="s2">&quot;quads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">translateQuads</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">delete</span><span class="o">.</span><span class="n">quads</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">insert</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">insert</span><span class="p">[</span><span class="s2">&quot;triples&quot;</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">insert</span><span class="p">[</span><span class="s2">&quot;quads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">translateQuads</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">insert</span><span class="o">.</span><span class="n">quads</span><span class="p">)</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">translateGroupGraphPattern</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown type of update operation: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">u</span><span class="p">)</span>

    <span class="n">u</span><span class="o">.</span><span class="n">prologue</span> <span class="o">=</span> <span class="n">prologue</span>
    <span class="k">return</span> <span class="n">u</span></div>


<div class="viewcode-block" id="translateUpdate"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateUpdate">[docs]</a><span class="k">def</span> <span class="nf">translateUpdate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initNs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of SPARQL Update Algebra expressions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prologue</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">request</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">prologue</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">request</span><span class="p">):</span>
        <span class="n">prologue</span> <span class="o">=</span> <span class="n">translatePrologue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">initNs</span><span class="p">,</span> <span class="n">prologue</span><span class="p">)</span>

        <span class="c1"># absolutize/resolve prefixes</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">translatePName</span><span class="p">,</span> <span class="n">prologue</span><span class="o">=</span><span class="n">prologue</span><span class="p">))</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_simplifyFilters</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="n">translatePath</span><span class="p">)</span>

        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translateUpdate1</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">prologue</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Update</span><span class="p">(</span><span class="n">prologue</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="translateQuery"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateQuery">[docs]</a><span class="k">def</span> <span class="nf">translateQuery</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initNs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate a query-parsetree to a SPARQL Algebra Expression</span>

<span class="sd">    Return a rdflib.plugins.sparql.sparql.Query object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We get in: (prologue, query)</span>

    <span class="n">prologue</span> <span class="o">=</span> <span class="n">translatePrologue</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">initNs</span><span class="p">)</span>

    <span class="c1"># absolutize/resolve prefixes</span>
    <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">visitPost</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">translatePName</span><span class="p">,</span> <span class="n">prologue</span><span class="o">=</span><span class="n">prologue</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">P</span><span class="p">,</span> <span class="n">PV</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">datasetClause</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">datasetClause</span>
    <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ConstructQuery&quot;</span><span class="p">:</span>

        <span class="n">template</span> <span class="o">=</span> <span class="n">triples</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">template</span><span class="p">)</span> <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">template</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">CompValue</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="n">template</span><span class="p">,</span> <span class="n">datasetClause</span><span class="o">=</span><span class="n">datasetClause</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">CompValue</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">datasetClause</span><span class="o">=</span><span class="n">datasetClause</span><span class="p">,</span> <span class="n">PV</span><span class="o">=</span><span class="n">PV</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">visitPost</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
    <span class="n">_traverseAgg</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">visitor</span><span class="o">=</span><span class="n">analyse</span><span class="p">)</span>
    <span class="n">_traverseAgg</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">_addVars</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Query</span><span class="p">(</span><span class="n">prologue</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="ExpressionNotCoveredException"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.ExpressionNotCoveredException">[docs]</a><span class="k">class</span> <span class="nc">ExpressionNotCoveredException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="translateAlgebra"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.translateAlgebra">[docs]</a><span class="k">def</span> <span class="nf">translateAlgebra</span><span class="p">(</span><span class="n">query_algebra</span><span class="p">:</span> <span class="n">Query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param query_algebra: An algebra returned by the function call algebra.translateQuery(parse_tree).</span>
<span class="sd">    :return: The query form generated from the SPARQL 1.1 algebra tree for select queries.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>

    <span class="k">def</span> <span class="nf">overwrite</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;query.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="n">old</span><span class="p">,</span>
        <span class="n">new</span><span class="p">,</span>
        <span class="n">search_from_match</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">search_from_match_occurrence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Read in the file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;query.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">filedata</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">find_nth</span><span class="p">(</span><span class="n">haystack</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">start</span>

        <span class="k">if</span> <span class="n">search_from_match</span> <span class="ow">and</span> <span class="n">search_from_match_occurrence</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">find_nth</span><span class="p">(</span>
                <span class="n">filedata</span><span class="p">,</span> <span class="n">search_from_match</span><span class="p">,</span> <span class="n">search_from_match_occurrence</span>
            <span class="p">)</span>
            <span class="n">filedata_pre</span> <span class="o">=</span> <span class="n">filedata</span><span class="p">[:</span><span class="n">position</span><span class="p">]</span>
            <span class="n">filedata_post</span> <span class="o">=</span> <span class="n">filedata</span><span class="p">[</span><span class="n">position</span><span class="p">:]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="n">filedata</span> <span class="o">=</span> <span class="n">filedata_pre</span> <span class="o">+</span> <span class="n">filedata_post</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filedata</span> <span class="o">=</span> <span class="n">filedata</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

        <span class="c1"># Write the file out again</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;query.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filedata</span><span class="p">)</span>

    <span class="n">aggr_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># type: dict</span>

    <span class="k">def</span> <span class="nf">convert_node_arg</span><span class="p">(</span><span class="n">node_arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_arg</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node_arg</span> <span class="ow">in</span> <span class="n">aggr_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">grp_var</span> <span class="o">=</span> <span class="n">aggr_vars</span><span class="p">[</span><span class="n">node_arg</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">grp_var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node_arg</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_arg</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node_arg</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_arg</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node_arg</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node_arg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                <span class="s2">&quot;The expression </span><span class="si">{0}</span><span class="s2"> might not be covered yet.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_arg</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">sparql_query_text</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         https://www.w3.org/TR/sparql11-query/#sparqlSyntax</span>

<span class="sd">        :param node:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
            <span class="c1"># 18.2 Query Forms</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;SelectQuery&quot;</span><span class="p">:</span>
                <span class="n">overwrite</span><span class="p">(</span><span class="s2">&quot;-*-SELECT-*- &quot;</span> <span class="o">+</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>

            <span class="c1"># 18.2 Graph Patterns</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;BGP&quot;</span><span class="p">:</span>
                <span class="c1"># Identifiers or Paths</span>
                <span class="c1"># Negated path throws a type error. Probably n3() method of negated paths should be fixed</span>
                <span class="n">triples</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">triple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">triple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
                    <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">triples</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{BGP}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">triples</span><span class="p">)</span>
                <span class="c1"># The dummy -*-SELECT-*- is placed during a SelectQuery or Multiset pattern in order to be able</span>
                <span class="c1"># to match extended variables in a specific Select-clause (see &quot;Extend&quot; below)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-*-SELECT-*-&quot;</span><span class="p">,</span> <span class="s2">&quot;SELECT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># If there is no &quot;Group By&quot; clause the placeholder will simply be deleted. Otherwise there will be</span>
                <span class="c1"># no matching {GroupBy} placeholder because it has already been replaced by &quot;group by variables&quot;</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{GroupBy}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Having}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Join&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Join}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;LeftJoin&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{LeftJoin}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}OPTIONAL{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Filter&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                        <span class="s2">&quot;This expression might not be covered yet.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
                    <span class="c1"># Filter with p=AggregateJoin = Having</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;AggregateJoin&quot;</span><span class="p">:</span>
                        <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Filter}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
                        <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Having}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;HAVING({&quot;</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="s2">&quot;})&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{Filter}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;FILTER({&quot;</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="s2">&quot;}) {&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Filter}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;FILTER({&quot;</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="s2">&quot;})&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Union&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Union}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}UNION{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Graph&quot;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;GRAPH &quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; {{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Graph}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Extend&quot;</span><span class="p">:</span>
                <span class="n">query_string</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;query.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">select_occurrences</span> <span class="o">=</span> <span class="n">query_string</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;-*-select-*-&quot;</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">n3</span><span class="p">(),</span>
                    <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; as &quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                    <span class="n">search_from_match</span><span class="o">=</span><span class="s2">&quot;-*-select-*-&quot;</span><span class="p">,</span>
                    <span class="n">search_from_match_occurrence</span><span class="o">=</span><span class="n">select_occurrences</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Extend}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Minus&quot;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}MINUS{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Minus}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Group&quot;</span><span class="p">:</span>
                <span class="n">group_by_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                            <span class="n">group_by_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">n3</span><span class="p">())</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                                <span class="s2">&quot;This expression might not be covered yet.&quot;</span>
                            <span class="p">)</span>
                    <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Group}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
                    <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{GroupBy}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;GROUP BY &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">group_by_vars</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Group}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;AggregateJoin&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{AggregateJoin}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">agg_func</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">A</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg_func</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                        <span class="n">identifier</span> <span class="o">=</span> <span class="n">agg_func</span><span class="o">.</span><span class="n">res</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                            <span class="s2">&quot;This expression might not be covered yet.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">aggr_vars</span><span class="p">[</span><span class="n">agg_func</span><span class="o">.</span><span class="n">res</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agg_func</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

                    <span class="n">agg_func_name</span> <span class="o">=</span> <span class="n">agg_func</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">distinct</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">agg_func</span><span class="o">.</span><span class="n">distinct</span><span class="p">:</span>
                        <span class="n">distinct</span> <span class="o">=</span> <span class="n">agg_func</span><span class="o">.</span><span class="n">distinct</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                    <span class="k">if</span> <span class="n">agg_func_name</span> <span class="o">==</span> <span class="s2">&quot;GroupConcat&quot;</span><span class="p">:</span>
                        <span class="n">replace</span><span class="p">(</span>
                            <span class="n">identifier</span><span class="p">,</span>
                            <span class="s2">&quot;GROUP_CONCAT&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
                            <span class="o">+</span> <span class="n">distinct</span>
                            <span class="o">+</span> <span class="n">agg_func</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                            <span class="o">+</span> <span class="s2">&quot;;SEPARATOR=&quot;</span>
                            <span class="o">+</span> <span class="n">agg_func</span><span class="o">.</span><span class="n">separator</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                            <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">replace</span><span class="p">(</span>
                            <span class="n">identifier</span><span class="p">,</span>
                            <span class="n">agg_func_name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                            <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
                            <span class="o">+</span> <span class="n">distinct</span>
                            <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">agg_func</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="c1"># For non-aggregated variables the aggregation function &quot;sample&quot; is automatically assigned.</span>
                    <span class="c1"># However, we do not want to have &quot;sample&quot; wrapped around non-aggregated variables. That is</span>
                    <span class="c1"># why we replace it. If &quot;sample&quot; is used on purpose it will not be replaced as the alias</span>
                    <span class="c1"># must be different from the variable in this case.</span>
                    <span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;(SAMPLE(</span><span class="si">{0}</span><span class="s2">) as </span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">agg_func</span><span class="o">.</span><span class="n">vars</span><span class="p">)),</span>
                        <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">agg_func</span><span class="o">.</span><span class="n">vars</span><span class="p">),</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;GroupGraphPatternSub&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;GroupGraphPatternSub&quot;</span><span class="p">,</span>
                    <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">part</span><span class="p">]),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;TriplesBlock&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;triplesblock&quot;</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{TriplesBlock}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">triple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                        <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                        <span class="o">+</span> <span class="n">triple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                        <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                        <span class="o">+</span> <span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                        <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
                        <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">triples</span>
                    <span class="p">),</span>
                <span class="p">)</span>

            <span class="c1"># 18.2 Solution modifiers</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ToList&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                    <span class="s2">&quot;This expression might not be covered yet.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;OrderBy&quot;</span><span class="p">:</span>
                <span class="n">order_conditions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                        <span class="n">var</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">cond</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">var</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cond</span> <span class="o">=</span> <span class="n">var</span>
                        <span class="n">order_conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                            <span class="s2">&quot;This expression might not be covered yet.&quot;</span>
                        <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{OrderBy}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{OrderConditions}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">order_conditions</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
                <span class="n">project_variables</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">PV</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                        <span class="n">project_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">n3</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                            <span class="s2">&quot;This expression might not be covered yet.&quot;</span>
                        <span class="p">)</span>
                <span class="n">order_by_pattern</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;OrderBy&quot;</span><span class="p">:</span>
                    <span class="n">order_by_pattern</span> <span class="o">=</span> <span class="s2">&quot;ORDER BY </span><span class="si">{OrderConditions}</span><span class="s2">&quot;</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Project}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">project_variables</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;{{&quot;</span>
                    <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span>
                    <span class="o">+</span> <span class="s2">&quot;}}&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{GroupBy}</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="n">order_by_pattern</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{Having}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Distinct&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Distinct}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;DISTINCT {&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Reduced&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Reduced}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;REDUCED {&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Slice&quot;</span><span class="p">:</span>
                <span class="nb">slice</span> <span class="o">=</span> <span class="s2">&quot;OFFSET &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; LIMIT &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Slice}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="o">+</span> <span class="nb">slice</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ToMultiSet&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;values&quot;</span><span class="p">:</span>
                    <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{ToMultiSet}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{ToMultiSet}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;{-*-SELECT-*- &quot;</span> <span class="o">+</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># 18.2 Property Path</span>

            <span class="c1"># 17 Expressions and Testing Values</span>
            <span class="c1"># # 17.3 Operator Mapping</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;RelationalExpression&quot;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">)):</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;(&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">)</span>
                <span class="n">condition</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{left}</span><span class="s2"> </span><span class="si">{operator}</span><span class="s2"> </span><span class="si">{right}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">left</span><span class="o">=</span><span class="n">expr</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">other</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{RelationalExpression}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ConditionalAndExpression&quot;</span><span class="p">:</span>
                <span class="n">inner_nodes</span> <span class="o">=</span> <span class="s2">&quot; &amp;&amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{ConditionalAndExpression}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &amp;&amp; &quot;</span> <span class="o">+</span> <span class="n">inner_nodes</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ConditionalOrExpression&quot;</span><span class="p">:</span>
                <span class="n">inner_nodes</span> <span class="o">=</span> <span class="s2">&quot; || &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{ConditionalOrExpression}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; || &quot;</span> <span class="o">+</span> <span class="n">inner_nodes</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;MultiplicativeExpression&quot;</span><span class="p">:</span>
                <span class="n">left_side</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">multiplication</span> <span class="o">=</span> <span class="n">left_side</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">):</span>
                    <span class="n">multiplication</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">operator</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                    <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{MultiplicativeExpression}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">multiplication</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;AdditiveExpression&quot;</span><span class="p">:</span>
                <span class="n">left_side</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">addition</span> <span class="o">=</span> <span class="n">left_side</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">):</span>
                    <span class="n">addition</span> <span class="o">+=</span> <span class="n">operator</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{AdditiveExpression}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">addition</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;UnaryNot&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{UnaryNot}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">))</span>

            <span class="c1"># # 17.4 Function Definitions</span>
            <span class="c1"># # # 17.4.1 Functional Forms</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;BOUND&quot;</span><span class="p">):</span>
                <span class="n">bound_var</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_BOUND}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;bound(&quot;</span> <span class="o">+</span> <span class="n">bound_var</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;IF&quot;</span><span class="p">):</span>
                <span class="n">arg2</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="n">arg3</span> <span class="o">=</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg3</span><span class="p">)</span>

                <span class="n">if_expression</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;IF(&quot;</span> <span class="o">+</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}, &quot;</span> <span class="o">+</span> <span class="n">arg2</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">arg3</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_IF}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">if_expression</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;COALESCE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_COALESCE}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;COALESCE(&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_EXISTS&quot;</span><span class="p">):</span>
                <span class="c1"># The node&#39;s name which we get with node.graph.name returns &quot;Join&quot; instead of GroupGraphPatternSub</span>
                <span class="c1"># According to https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#rExistsFunc</span>
                <span class="c1"># ExistsFunc can only have a GroupGraphPattern as parameter. However, when we print the query algebra</span>
                <span class="c1"># we get a GroupGraphPatternSub</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_EXISTS}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;EXISTS &quot;</span> <span class="o">+</span> <span class="s2">&quot;{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span><span class="p">)</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">visitPre</span><span class="o">=</span><span class="n">sparql_query_text</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_NOTEXISTS&quot;</span><span class="p">):</span>
                <span class="c1"># The node&#39;s name which we get with node.graph.name returns &quot;Join&quot; instead of GroupGraphPatternSub</span>
                <span class="c1"># According to https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#rNotExistsFunc</span>
                <span class="c1"># NotExistsFunc can only have a GroupGraphPattern as parameter. However, when we print the query algebra</span>
                <span class="c1"># we get a GroupGraphPatternSub</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_NOTEXISTS}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;NOT EXISTS &quot;</span> <span class="o">+</span> <span class="s2">&quot;{{&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;}}&quot;</span>
                <span class="p">)</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">visitPre</span><span class="o">=</span><span class="n">sparql_query_text</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span>
            <span class="c1"># # # # 17.4.1.5 logical-or: Covered in &quot;RelationalExpression&quot;</span>
            <span class="c1"># # # # 17.4.1.6 logical-and: Covered in &quot;RelationalExpression&quot;</span>
            <span class="c1"># # # # 17.4.1.7 RDFterm-equal: Covered in &quot;RelationalExpression&quot;</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;sameTerm&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_sameTerm}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;SAMETERM(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># # # # IN: Covered in &quot;RelationalExpression&quot;</span>
            <span class="c1"># # # # NOT IN: Covered in &quot;RelationalExpression&quot;</span>

            <span class="c1"># # # 17.4.2 Functions on RDF Terms</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_isIRI&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_isIRI}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;isIRI(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_isBLANK&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_isBLANK}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;isBLANK(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_isLITERAL&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_isLITERAL}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;isLITERAL(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_isNUMERIC&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_isNUMERIC}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;isNUMERIC(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STR&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_STR}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;STR(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_LANG&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_LANG}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;LANG(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_DATATYPE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_DATATYPE}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;DATATYPE(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_IRI&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_IRI}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;IRI(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_BNODE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_BNODE}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;BNODE(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;STRDT&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRDT}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;STRDT(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRLANG&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRLANG}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;STRLANG(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_UUID&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_UUID}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;UUID()&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRUUID&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_STRUUID}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;STRUUID()&quot;</span><span class="p">)</span>

            <span class="c1"># # # 17.4.3 Functions on Strings</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRLEN&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRLEN}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;STRLEN(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_SUBSTR&quot;</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;SUBSTR(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_SUBSTR}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_UCASE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_UCASE}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;UCASE(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_LCASE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_LCASE}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;LCASE(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRSTARTS&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRSTARTS}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;STRSTARTS(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRENDS&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRENDS}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;STRENDS(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_CONTAINS&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_CONTAINS}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;CONTAINS(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRBEFORE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRBEFORE}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;STRBEFORE(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_STRAFTER&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_STRAFTER}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;STRAFTER(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_ENCODE_FOR_URI&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_ENCODE_FOR_URI}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ENCODE_FOR_URI(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_CONCAT&quot;</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;CONCAT(</span><span class="si">{vars}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">vars</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_CONCAT}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Builtin_LANGMATCHES&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_LANGMATCHES}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LANGMATCHES(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;REGEX&quot;</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="p">),</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pattern</span><span class="p">)]</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;REGEX(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_REGEX}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;REPLACE&quot;</span><span class="p">):</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_REPLACE}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;REPLACE(&quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">replacement</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># # # 17.4.4 Functions on Numerics</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_ABS&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_ABS}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;ABS(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_ROUND&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_ROUND}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;ROUND(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_CEIL&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_CEIL}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;CEIL(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_FLOOR&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_FLOOR}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;FLOOR(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_RAND&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_RAND}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;RAND()&quot;</span><span class="p">)</span>

            <span class="c1"># # # 17.4.5 Functions on Dates and Times</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_NOW&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_NOW}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;NOW()&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_YEAR&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_YEAR}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;YEAR(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_MONTH&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_MONTH}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;MONTH(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_DAY&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_DAY}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;DAY(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_HOURS&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_HOURS}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;HOURS(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_MINUTES&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_MINUTES}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;MINUTES(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_SECONDS&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_SECONDS}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;SECONDS(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_TIMEZONE&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_TIMEZONE}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;TIMEZONE(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_TZ&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_TZ}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;TZ(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>

            <span class="c1"># # # 17.4.6 Hash functions</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_MD5&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_MD5}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;MD5(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_SHA1&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{Builtin_SHA1}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;SHA1(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_SHA256&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_SHA256}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;SHA256(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_SHA384&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_SHA384}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;SHA384(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Builtin_SHA512&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{Builtin_SHA512}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;SHA512(&quot;</span> <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Other</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;values&quot;</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">n3</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                            <span class="s2">&quot;The expression </span><span class="si">{0}</span><span class="s2"> might not be covered yet.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="s2">&quot;VALUES (&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

                <span class="n">rows</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                            <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">term</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>
                            <span class="p">)</span>  <span class="c1"># n3() is not part of Identifier class but every subclass has it</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                            <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">ExpressionNotCoveredException</span><span class="p">(</span>
                                <span class="s2">&quot;The expression </span><span class="si">{0}</span><span class="s2"> might not be covered yet.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">term</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                    <span class="n">rows</span> <span class="o">+=</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

                <span class="n">replace</span><span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">values</span> <span class="o">+</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">rows</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ServiceGraphPattern&quot;</span><span class="p">:</span>
                <span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{ServiceGraphPattern}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;SERVICE &quot;</span>
                    <span class="o">+</span> <span class="n">convert_node_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;{&quot;</span>
                    <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span>
                    <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">visitPre</span><span class="o">=</span><span class="n">sparql_query_text</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span>
            <span class="c1"># else:</span>
            <span class="c1">#     raise ExpressionNotCoveredException(&quot;The expression {0} might not be covered yet.&quot;.format(node.name))</span>

    <span class="n">traverse</span><span class="p">(</span><span class="n">query_algebra</span><span class="o">.</span><span class="n">algebra</span><span class="p">,</span> <span class="n">visitPre</span><span class="o">=</span><span class="n">sparql_query_text</span><span class="p">)</span>
    <span class="n">query_from_algebra</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;query.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;query.txt&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">query_from_algebra</span></div>


<div class="viewcode-block" id="pprintAlgebra"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.algebra.pprintAlgebra">[docs]</a><span class="k">def</span> <span class="nf">pprintAlgebra</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">):</span>
        <span class="c1"># if isinstance(p, list):</span>
        <span class="c1">#     print &quot;[ &quot;</span>
        <span class="c1">#     for x in p: pp(x,ind)</span>
        <span class="c1">#     print &quot;%s ]&quot;%ind</span>
        <span class="c1">#     return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CompValue</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2"> =&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">ind</span><span class="p">,</span>
                    <span class="n">k</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">pp</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ind</span> <span class="o">+</span> <span class="s2">&quot;    &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">ind</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">pp</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">algebra</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># it&#39;s update, just a list</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">pp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">rdflib.plugins.sparql</span> <span class="kn">import</span> <span class="n">parser</span>
    <span class="kn">import</span> <span class="nn">os.path</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">pq</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parseQuery</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------&quot;</span><span class="p">)</span>
    <span class="n">tq</span> <span class="o">=</span> <span class="n">translateQuery</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
    <span class="n">pprintAlgebra</span><span class="p">(</span><span class="n">tq</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/RDFlib.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">rdflib 6.2.0-alpha documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rdflib.plugins.sparql.algebra</a></li> 
      </ul>
    </div>
<div class="footer">
    &copy; Copyright 2009 - 2021, RDFLib Team.
  Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 4.3.2.
  <br />Theme based on <a href="http://readthedocs.org/">Read The Docs</a>

</div>





  </body>
</html>