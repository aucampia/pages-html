
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>rdflib.plugins.stores.sparqlstore &#8212; rdflib 6.2.0-alpha documentation</title>

<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/>


    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/rtd.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../../../../../_static/searchtools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/RDFlib.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">rdflib 6.2.0-alpha documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rdflib.plugins.stores.sparqlstore</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for rdflib.plugins.stores.sparqlstore</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is an RDFLib store around Ivan Herman et al.&#39;s SPARQL service wrapper.</span>
<span class="sd">This was first done in layer-cake, and then ported to RDFLib</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">from</span> <span class="nn">.sparqlconnector</span> <span class="kn">import</span> <span class="n">SPARQLConnector</span>

<span class="kn">from</span> <span class="nn">rdflib.plugins.stores.regexmatching</span> <span class="kn">import</span> <span class="n">NATIVE_REGEX</span>

<span class="kn">from</span> <span class="nn">rdflib.store</span> <span class="kn">import</span> <span class="n">Store</span>
<span class="kn">from</span> <span class="nn">rdflib</span> <span class="kn">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">BNode</span>
<span class="kn">from</span> <span class="nn">rdflib.graph</span> <span class="kn">import</span> <span class="n">DATASET_DEFAULT_GRAPH_ID</span>
<span class="kn">from</span> <span class="nn">rdflib.term</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="c1"># Defines some SPARQL keywords</span>
<span class="n">LIMIT</span> <span class="o">=</span> <span class="s2">&quot;LIMIT&quot;</span>
<span class="n">OFFSET</span> <span class="o">=</span> <span class="s2">&quot;OFFSET&quot;</span>
<span class="n">ORDERBY</span> <span class="o">=</span> <span class="s2">&quot;ORDER BY&quot;</span>

<span class="n">BNODE_IDENT_PATTERN</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;label&gt;_\:[^\s]+)&quot;</span><span class="p">)</span>

<span class="n">NodeToSparql</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_node_to_sparql</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BNode</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;SPARQLStore does not support BNodes! &quot;</span>
            <span class="s2">&quot;See http://www.w3.org/TR/sparql11-query/#BGPsparqlBNodes&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>


<div class="viewcode-block" id="SPARQLStore"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore">[docs]</a><span class="k">class</span> <span class="nc">SPARQLStore</span><span class="p">(</span><span class="n">SPARQLConnector</span><span class="p">,</span> <span class="n">Store</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An RDFLib store around a SPARQL endpoint</span>

<span class="sd">    This is context-aware and should work as expected</span>
<span class="sd">    when a context is specified.</span>

<span class="sd">    For ConjunctiveGraphs, reading is done from the &quot;default graph&quot;. Exactly</span>
<span class="sd">    what this means depends on your endpoint, because SPARQL does not offer a</span>
<span class="sd">    simple way to query the union of all graphs as it would be expected for a</span>
<span class="sd">    ConjuntiveGraph. This is why we recommend using Dataset instead, which is</span>
<span class="sd">    motivated by the SPARQL 1.1.</span>

<span class="sd">    Fuseki/TDB has a flag for specifying that the default graph</span>
<span class="sd">    is the union of all graphs (``tdb:unionDefaultGraph`` in the Fuseki config).</span>

<span class="sd">    .. warning:: By default the SPARQL Store does not support blank-nodes!</span>

<span class="sd">                 As blank-nodes act as variables in SPARQL queries,</span>
<span class="sd">                 there is no way to query for a particular blank node without</span>
<span class="sd">                 using non-standard SPARQL extensions.</span>

<span class="sd">                 See http://www.w3.org/TR/sparql11-query/#BGPsparqlBNodes</span>

<span class="sd">    You can make use of such extensions through the ``node_to_sparql``</span>
<span class="sd">    argument. For example if you want to transform BNode(&#39;0001&#39;) into</span>
<span class="sd">    &quot;&lt;bnode:b0001&gt;&quot;, you can use a function like this:</span>

<span class="sd">    &gt;&gt;&gt; def my_bnode_ext(node):</span>
<span class="sd">    ...    if isinstance(node, BNode):</span>
<span class="sd">    ...        return &#39;&lt;bnode:b%s&gt;&#39; % node</span>
<span class="sd">    ...    return _node_to_sparql(node)</span>
<span class="sd">    &gt;&gt;&gt; store = SPARQLStore(&#39;http://dbpedia.org/sparql&#39;,</span>
<span class="sd">    ...                     node_to_sparql=my_bnode_ext)</span>

<span class="sd">    You can request a particular result serialization with the</span>
<span class="sd">    ``returnFormat`` parameter. This is a string that must have a</span>
<span class="sd">    matching plugin registered. Built in is support for ``xml``,</span>
<span class="sd">    ``json``, ``csv``, ``tsv`` and ``application/rdf+xml``.</span>

<span class="sd">    The underlying SPARQLConnector uses the urllib library.</span>
<span class="sd">    Any extra kwargs passed to the SPARQLStore connector are passed to</span>
<span class="sd">    urllib when doing HTTP calls. I.e. you have full control of</span>
<span class="sd">    cookies/auth/headers.</span>

<span class="sd">    Form example:</span>

<span class="sd">    &gt;&gt;&gt; store = SPARQLStore(&#39;...my endpoint ...&#39;, auth=(&#39;user&#39;,&#39;pass&#39;))</span>

<span class="sd">    will use HTTP basic auth.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">formula_aware</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">transaction_aware</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">graph_aware</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">regex_matching</span> <span class="o">=</span> <span class="n">NATIVE_REGEX</span>

<div class="viewcode-block" id="SPARQLStore.__init__"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">query_endpoint</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sparql11</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">context_aware</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">node_to_sparql</span><span class="p">:</span> <span class="n">NodeToSparql</span> <span class="o">=</span> <span class="n">_node_to_sparql</span><span class="p">,</span>
        <span class="n">returnFormat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xml&quot;</span><span class="p">,</span>
        <span class="n">auth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">sparqlconnector_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SPARQLStore</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">query_endpoint</span><span class="o">=</span><span class="n">query_endpoint</span><span class="p">,</span>
            <span class="n">returnFormat</span><span class="o">=</span><span class="n">returnFormat</span><span class="p">,</span>
            <span class="n">auth</span><span class="o">=</span><span class="n">auth</span><span class="p">,</span>
            <span class="o">**</span><span class="n">sparqlconnector_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span> <span class="o">=</span> <span class="n">node_to_sparql</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsBindings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparql11</span> <span class="o">=</span> <span class="n">sparql11</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context_aware</span> <span class="o">=</span> <span class="n">context_aware</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_aware</span> <span class="o">=</span> <span class="n">context_aware</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queries</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SPARQLStore.open"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is included so that calls to this Store via Graph, e.g. Graph(&quot;SPARQLStore&quot;),</span>
<span class="sd">        can set the required parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_endpoint</span> <span class="o">=</span> <span class="n">configuration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;configuration must be a string (a single query endpoint URI)&quot;</span>
            <span class="p">)</span></div>

    <span class="c1"># Database Management Methods</span>
<div class="viewcode-block" id="SPARQLStore.create"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The SPARQL Store is read only. Try SPARQLUpdateStore for read/write.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.destroy"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

    <span class="c1"># Transactional interfaces</span>
<div class="viewcode-block" id="SPARQLStore.commit"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.commit">[docs]</a>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.rollback"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.rollback">[docs]</a>    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.add"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quoted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.addN"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.addN">[docs]</a>    <span class="k">def</span> <span class="nf">addN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quads</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.remove"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.update"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">initNs</span><span class="o">=</span><span class="p">{},</span> <span class="n">initBindings</span><span class="o">=</span><span class="p">{},</span> <span class="n">queryGraph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">DEBUG</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SPARQLStore</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_inject_prefixes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">extra_bindings</span><span class="p">):</span>
        <span class="n">bindings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsBindings</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">extra_bindings</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bindings</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">query</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;PREFIX </span><span class="si">%s</span><span class="s2">: &lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">]),</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># separate ns_bindings from query with an empty line</span>
                <span class="n">query</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SPARQLStore.query"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.query">[docs]</a>    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">initNs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initBindings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">queryGraph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">DEBUG</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">DEBUG</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initNs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">initNs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inject_prefixes</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">initNs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initBindings</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparql11</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;initBindings not supported for SPARQL 1.0 Endpoints.&quot;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initBindings</span><span class="p">)</span>

            <span class="c1"># VALUES was added to SPARQL 1.1 on 2012/07/24</span>
            <span class="n">query</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">VALUES ( </span><span class="si">%s</span><span class="s2"> )</span><span class="se">\n</span><span class="s2">{ ( </span><span class="si">%s</span><span class="s2"> ) }</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">),</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span><span class="p">(</span><span class="n">initBindings</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span>
            <span class="n">query</span><span class="p">,</span> <span class="n">default_graph</span><span class="o">=</span><span class="n">queryGraph</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_contextual</span><span class="p">(</span><span class="n">queryGraph</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.triples"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.triples">[docs]</a>    <span class="k">def</span> <span class="nf">triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spo</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        - tuple **(s, o, p)**</span>
<span class="sd">          the triple used as filter for the SPARQL select.</span>
<span class="sd">          (None, None, None) means anything.</span>
<span class="sd">        - context **context**</span>
<span class="sd">          the graph effectively calling this method.</span>

<span class="sd">        Returns a tuple of triples executing essentially a SPARQL like</span>
<span class="sd">        SELECT ?subj ?pred ?obj WHERE { ?subj ?pred ?obj }</span>

<span class="sd">        **context** may include three parameter</span>
<span class="sd">        to refine the underlying query:</span>

<span class="sd">        * LIMIT: an integer to limit the number of results</span>
<span class="sd">        * OFFSET: an integer to enable paging of results</span>
<span class="sd">        * ORDERBY: an instance of Variable(&#39;s&#39;), Variable(&#39;o&#39;) or Variable(&#39;p&#39;) or, by default, the first &#39;None&#39; from the given triple</span>

<span class="sd">        .. warning::</span>

<span class="sd">            - Using LIMIT or OFFSET automatically include ORDERBY otherwise this is</span>
<span class="sd">              because the results are retrieved in a not deterministic way (depends on</span>
<span class="sd">              the walking path on the graph)</span>
<span class="sd">            - Using OFFSET without defining LIMIT will discard the first OFFSET - 1 results</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            a_graph.LIMIT = limit</span>
<span class="sd">            a_graph.OFFSET = offset</span>
<span class="sd">            triple_generator = a_graph.triples(mytriple):</span>
<span class="sd">            # do something</span>
<span class="sd">            # Removes LIMIT and OFFSET if not required for the next triple() calls</span>
<span class="sd">            del a_graph.LIMIT</span>
<span class="sd">            del a_graph.OFFSET</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">spo</span>

        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">term</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">])</span>
            <span class="n">verb</span> <span class="o">=</span> <span class="s2">&quot;SELECT </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verb</span> <span class="o">=</span> <span class="s2">&quot;ASK&quot;</span>

        <span class="n">nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span>
        <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> { </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> }&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">nts</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>

        <span class="c1"># The ORDER BY is necessary</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">LIMIT</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">OFFSET</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ORDERBY</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">o</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ORDERBY</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ORDERBY</span><span class="p">),</span> <span class="n">Variable</span>
            <span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ORDERBY</span><span class="p">)</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ORDERBY</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">n3</span><span class="p">())</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot; LIMIT </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">LIMIT</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot; OFFSET </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">OFFSET</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">default_graph</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">identifier</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_contextual</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">401</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;It looks like you need to authenticate with this SPARQL Store. HTTP unauthorized&quot;</span>
                    <span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">),</span>
                <span class="p">),</span> <span class="kc">None</span>  <span class="c1"># why is the context here not the passed in graph &#39;context&#39;?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">askAnswer</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">o</span><span class="p">),</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SPARQLStore.triples_choices"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.triples_choices">[docs]</a>    <span class="k">def</span> <span class="nf">triples_choices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A variant of triples that can take a list of terms instead of a</span>
<span class="sd">        single term in any slot.  Stores can implement this to optimize</span>
<span class="sd">        the response time from the import default &#39;fallback&#39; implementation,</span>
<span class="sd">        which will iterate over each term in the list and dispatch to</span>
<span class="sd">        triples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Triples choices currently not supported&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.__len__"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparql11</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;For performance reasons, this is not&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;supported for sparql1.0 endpoints&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;SELECT (count(*) as ?c) WHERE {?s ?p ?o .}&quot;</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span>
                <span class="n">q</span><span class="p">,</span>
                <span class="n">default_graph</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">identifier</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_contextual</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
                <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">result</span><span class="p">))</span><span class="o">.</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.contexts"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.contexts">[docs]</a>    <span class="k">def</span> <span class="nf">contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triple</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over results to &quot;SELECT ?NAME { GRAPH ?NAME { ?s ?p ?o } }&quot;</span>
<span class="sd">        or &quot;SELECT ?NAME { GRAPH ?NAME {} }&quot; if triple is `None`.</span>

<span class="sd">        Returns instances of this store with the SPARQL wrapper</span>
<span class="sd">        object updated via addNamedGraph(?NAME).</span>

<span class="sd">        This causes a named-graph-uri key / value  pair to be sent over</span>
<span class="sd">        the protocol.</span>

<span class="sd">        Please note that some SPARQL endpoints are not able to find empty named</span>
<span class="sd">        graphs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">triple</span><span class="p">:</span>
            <span class="n">nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">triple</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">nts</span><span class="p">(</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="k">else</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)),</span>
                <span class="n">nts</span><span class="p">(</span><span class="n">p</span> <span class="k">if</span> <span class="n">p</span> <span class="k">else</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)),</span>
                <span class="n">nts</span><span class="p">(</span><span class="n">o</span> <span class="k">if</span> <span class="n">o</span> <span class="k">else</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)),</span>
            <span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;SELECT ?name WHERE { GRAPH ?name { </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> }}&quot;</span> <span class="o">%</span> <span class="n">params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;SELECT ?name WHERE { GRAPH ?name </span><span class="si">{}</span><span class="s2"> }&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span></div>

    <span class="c1"># Namespace persistence interface implementation</span>
<div class="viewcode-block" id="SPARQLStore.bind"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.bind">[docs]</a>    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsBindings</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">namespace</span></div>

<div class="viewcode-block" id="SPARQLStore.prefix"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.prefix">[docs]</a>    <span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsBindings</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.namespace"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.namespace">[docs]</a>    <span class="k">def</span> <span class="nf">namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsBindings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.namespaces"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.namespaces">[docs]</a>    <span class="k">def</span> <span class="nf">namespaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">ns</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsBindings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">ns</span></div>

<div class="viewcode-block" id="SPARQLStore.add_graph"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.add_graph">[docs]</a>    <span class="k">def</span> <span class="nf">add_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLStore.remove_graph"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.remove_graph">[docs]</a>    <span class="k">def</span> <span class="nf">remove_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The SPARQL store is read only&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_is_contextual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns `True` if the &quot;GRAPH&quot; keyword must appear</span>
<span class="sd">        in the final SPARQL query sent to the endpoint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">context_aware</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">graph</span> <span class="o">!=</span> <span class="s2">&quot;__UNION__&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">identifier</span> <span class="o">!=</span> <span class="n">DATASET_DEFAULT_GRAPH_ID</span>

<div class="viewcode-block" id="SPARQLStore.subjects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.subjects">[docs]</a>    <span class="k">def</span> <span class="nf">subjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of subjects with the given predicate and object&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLStore.predicates"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of predicates with the given subject and object&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLStore.objects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.objects">[docs]</a>    <span class="k">def</span> <span class="nf">objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of objects with the given subject and predicate&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLStore.subject_predicates"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.subject_predicates">[docs]</a>    <span class="k">def</span> <span class="nf">subject_predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of (subject, predicate) tuples for the given object&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLStore.subject_objects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.subject_objects">[docs]</a>    <span class="k">def</span> <span class="nf">subject_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of (subject, object) tuples for the given predicate&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLStore.predicate_objects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLStore.predicate_objects">[docs]</a>    <span class="k">def</span> <span class="nf">predicate_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of (predicate, object) tuples for the given subject&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="SPARQLUpdateStore"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore">[docs]</a><span class="k">class</span> <span class="nc">SPARQLUpdateStore</span><span class="p">(</span><span class="n">SPARQLStore</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A store using SPARQL queries for reading and SPARQL Update for changes.</span>

<span class="sd">    This can be context-aware, if so, any changes will be to the given named</span>
<span class="sd">    graph only.</span>

<span class="sd">    In favor of the SPARQL 1.1 motivated Dataset, we advise against using this</span>
<span class="sd">    with ConjunctiveGraphs, as it reads and writes from and to the</span>
<span class="sd">    &quot;default graph&quot;. Exactly what this means depends on the endpoint and can</span>
<span class="sd">    result in confusion.</span>

<span class="sd">    For Graph objects, everything works as expected.</span>

<span class="sd">    See the :class:`SPARQLStore` base class for more information.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">where_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;(?P&lt;where&gt;WHERE\s*\{)&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>

    <span class="c1">##############################################################</span>
    <span class="c1"># Regex for injecting GRAPH blocks into updates on a context #</span>
    <span class="c1">##############################################################</span>

    <span class="c1"># Observations on the SPARQL grammar (http://www.w3.org/TR/2013/REC-sparql11-query-20130321/):</span>
    <span class="c1"># 1. Only the terminals STRING_LITERAL1, STRING_LITERAL2,</span>
    <span class="c1">#    STRING_LITERAL_LONG1, STRING_LITERAL_LONG2, and comments can contain</span>
    <span class="c1">#    curly braces.</span>
    <span class="c1"># 2. The non-terminals introduce curly braces in pairs only.</span>
    <span class="c1"># 3. Unescaped &quot; can occur only in strings and comments.</span>
    <span class="c1"># 3. Unescaped &#39; can occur only in strings, comments, and IRIRefs.</span>
    <span class="c1"># 4. \ always escapes the following character, especially \&quot;, \&#39;, and</span>
    <span class="c1">#    \\ denote literal &quot;, &#39;, and \ respectively.</span>
    <span class="c1"># 5. # always starts a comment outside of string and IRI</span>
    <span class="c1"># 6. A comment ends at the next newline</span>
    <span class="c1"># 7. IRIREFs need to be detected, as they may contain # without starting a comment</span>
    <span class="c1"># 8. PrefixedNames do not contain a #</span>
    <span class="c1"># As a consequence, it should be rather easy to detect strings and comments</span>
    <span class="c1"># in order to avoid unbalanced curly braces.</span>

    <span class="c1"># From the SPARQL grammar</span>
    <span class="n">STRING_LITERAL1</span> <span class="o">=</span> <span class="s2">&quot;&#39;([^&#39;</span><span class="se">\\\\</span><span class="s2">]|</span><span class="se">\\\\</span><span class="s2">.)*&#39;&quot;</span>
    <span class="n">STRING_LITERAL2</span> <span class="o">=</span> <span class="s1">&#39;&quot;([^&quot;</span><span class="se">\\\\</span><span class="s1">]|</span><span class="se">\\\\</span><span class="s1">.)*&quot;&#39;</span>
    <span class="n">STRING_LITERAL_LONG1</span> <span class="o">=</span> <span class="s2">&quot;&#39;&#39;&#39;((&#39;|&#39;&#39;)?([^&#39;</span><span class="se">\\\\</span><span class="s2">]|</span><span class="se">\\\\</span><span class="s2">.))*&#39;&#39;&#39;&quot;</span>
    <span class="n">STRING_LITERAL_LONG2</span> <span class="o">=</span> <span class="s1">&#39;&quot;&quot;&quot;((&quot;|&quot;&quot;)?([^&quot;</span><span class="se">\\\\</span><span class="s1">]|</span><span class="se">\\\\</span><span class="s1">.))*&quot;&quot;&quot;&#39;</span>
    <span class="n">String</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">STRING_LITERAL1</span><span class="p">,</span>
        <span class="n">STRING_LITERAL2</span><span class="p">,</span>
        <span class="n">STRING_LITERAL_LONG1</span><span class="p">,</span>
        <span class="n">STRING_LITERAL_LONG2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">IRIREF</span> <span class="o">=</span> <span class="s1">&#39;&lt;([^&lt;&gt;&quot;</span><span class="si">{}</span><span class="s1">|^`</span><span class="se">\\</span><span class="s1">]</span><span class="se">\\\\</span><span class="s1">[</span><span class="se">\\</span><span class="s1">x00-</span><span class="se">\\</span><span class="s1">x20])*&gt;&#39;</span>
    <span class="n">COMMENT</span> <span class="o">=</span> <span class="s2">&quot;#[^</span><span class="se">\\</span><span class="s2">x0D</span><span class="se">\\</span><span class="s2">x0A]*([</span><span class="se">\\</span><span class="s2">x0D</span><span class="se">\\</span><span class="s2">x0A]|</span><span class="se">\\</span><span class="s2">Z)&quot;</span>

    <span class="c1"># Simplified grammar to find { at beginning and } at end of blocks</span>
    <span class="n">BLOCK_START</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span>
    <span class="n">BLOCK_END</span> <span class="o">=</span> <span class="s2">&quot;}&quot;</span>
    <span class="n">ESCAPED</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">.&quot;</span>

    <span class="c1"># Match anything that doesn&#39;t start or end a block:</span>
    <span class="n">BlockContent</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">IRIREF</span><span class="p">,</span> <span class="n">COMMENT</span><span class="p">,</span> <span class="n">ESCAPED</span><span class="p">)</span>
    <span class="n">BlockFinding</span> <span class="o">=</span> <span class="s2">&quot;(?P&lt;block_start&gt;</span><span class="si">%s</span><span class="s2">)|(?P&lt;block_end&gt;</span><span class="si">%s</span><span class="s2">)|(?P&lt;block_content&gt;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">BLOCK_START</span><span class="p">,</span>
        <span class="n">BLOCK_END</span><span class="p">,</span>
        <span class="n">BlockContent</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">BLOCK_FINDING_PATTERN</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">BlockFinding</span><span class="p">)</span>

    <span class="c1"># Note that BLOCK_FINDING_PATTERN.finditer() will not cover the whole</span>
    <span class="c1"># string with matches. Everything that is not matched will have to be</span>
    <span class="c1"># part of the modified query as is.</span>

    <span class="c1">##################################################################</span>

<div class="viewcode-block" id="SPARQLUpdateStore.__init__"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">query_endpoint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update_endpoint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sparql11</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">context_aware</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">postAsEncoded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autocommit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dirty_reads</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param autocommit if set, the store will commit after every</span>
<span class="sd">        writing operations. If False, we only make queries on the</span>
<span class="sd">        server once commit is called.</span>

<span class="sd">        :param dirty_reads if set, we do not commit before reading. So you</span>
<span class="sd">        cannot read what you wrote before manually calling commit.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">SPARQLStore</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">query_endpoint</span><span class="p">,</span>
            <span class="n">sparql11</span><span class="p">,</span>
            <span class="n">context_aware</span><span class="p">,</span>
            <span class="n">update_endpoint</span><span class="o">=</span><span class="n">update_endpoint</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">postAsEncoded</span> <span class="o">=</span> <span class="n">postAsEncoded</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="o">=</span> <span class="n">autocommit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirty_reads</span> <span class="o">=</span> <span class="n">dirty_reads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updates</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is included so that calls to this Store via Graph, e.g.</span>
<span class="sd">        Graph(&quot;SPARQLStore&quot;), can set the required parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_endpoint</span> <span class="o">=</span> <span class="n">configuration</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_endpoint</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;configuration must be either a string (a single query endpoint URI) &quot;</span>
                <span class="s2">&quot;or a tuple (a query/update endpoint URI pair)&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="SPARQLUpdateStore.query"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.query">[docs]</a>    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirty_reads</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SPARQLStore</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.triples"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.triples">[docs]</a>    <span class="k">def</span> <span class="nf">triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirty_reads</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SPARQLStore</span><span class="o">.</span><span class="n">triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.contexts"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.contexts">[docs]</a>    <span class="k">def</span> <span class="nf">contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirty_reads</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SPARQLStore</span><span class="o">.</span><span class="n">contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.__len__"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirty_reads</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SPARQLStore</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO: FIXME: open is defined twice</span>
<div class="viewcode-block" id="SPARQLUpdateStore.open"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># type: ignore[no-redef]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sets the endpoint URLs for this SPARQLStore</span>

<span class="sd">        :param configuration: either a tuple of (query_endpoint, update_endpoint),</span>
<span class="sd">            or a string with the endpoint which is configured as query and update endpoint</span>
<span class="sd">        :param create: if True an exception is thrown.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot create a SPARQL Endpoint&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_endpoint</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_endpoint</span> <span class="o">=</span> <span class="n">configuration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span> <span class="o">=</span> <span class="n">configuration</span></div>

    <span class="k">def</span> <span class="nf">_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span>

    <span class="c1"># Transactional interfaces</span>
<div class="viewcode-block" id="SPARQLUpdateStore.commit"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.commit">[docs]</a>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add(), addN(), and remove() are transactional to reduce overhead of many small edits.</span>
<span class="sd">        Read and update() calls will automatically commit any outstanding edits.</span>
<span class="sd">        This should behave as expected most of the time, except that alternating writes</span>
<span class="sd">        and reads can degenerate to the original call-per-triple situation that originally existed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edits</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.rollback"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.rollback">[docs]</a>    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edits</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.add"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spo</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quoted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a triple to the store of triples.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;UpdateEndpoint is not set&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">quoted</span>
        <span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="n">spo</span>

        <span class="n">nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span>
        <span class="n">triple</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> .&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nts</span><span class="p">(</span><span class="n">subject</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">predicate</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_contextual</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;INSERT DATA { GRAPH </span><span class="si">%s</span><span class="s2"> { </span><span class="si">%s</span><span class="s2"> } }&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nts</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">triple</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;INSERT DATA { </span><span class="si">%s</span><span class="s2"> }&quot;</span> <span class="o">%</span> <span class="n">triple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.addN"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.addN">[docs]</a>    <span class="k">def</span> <span class="nf">addN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a list of quads to the store.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;UpdateEndpoint is not set - call &#39;open&#39;&quot;</span><span class="p">)</span>

        <span class="n">contexts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">quads</span><span class="p">:</span>
            <span class="n">contexts</span><span class="p">[</span><span class="n">context</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span>
        <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">contexts</span><span class="p">:</span>
            <span class="n">triples</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> .&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nts</span><span class="p">(</span><span class="n">subject</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">predicate</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">contexts</span><span class="p">[</span><span class="n">context</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;INSERT DATA { GRAPH </span><span class="si">%s</span><span class="s2"> { </span><span class="si">%s</span><span class="s2"> } }</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">nts</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">triples</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">()</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.remove"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spo</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a triple from the store&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;UpdateEndpoint is not set - call &#39;open&#39;&quot;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="n">spo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subject</span><span class="p">:</span>
            <span class="n">subject</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">:</span>
            <span class="n">predicate</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>

        <span class="n">nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span>
        <span class="n">triple</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> .&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nts</span><span class="p">(</span><span class="n">subject</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">predicate</span><span class="p">),</span> <span class="n">nts</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_contextual</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
            <span class="n">cid</span> <span class="o">=</span> <span class="n">nts</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;WITH </span><span class="si">%(graph)s</span><span class="s2"> DELETE { </span><span class="si">%(triple)s</span><span class="s2"> } WHERE { </span><span class="si">%(triple)s</span><span class="s2"> }&quot;</span> <span class="o">%</span> <span class="p">{</span>
                <span class="s2">&quot;graph&quot;</span><span class="p">:</span> <span class="n">cid</span><span class="p">,</span>
                <span class="s2">&quot;triple&quot;</span><span class="p">:</span> <span class="n">triple</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;DELETE { </span><span class="si">%s</span><span class="s2"> } WHERE { </span><span class="si">%s</span><span class="s2"> } &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">triple</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.setTimeout"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.setTimeout">[docs]</a>    <span class="k">def</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updates</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">SPARQLConnector</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">)</span>

<div class="viewcode-block" id="SPARQLUpdateStore.update"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">initNs</span><span class="o">=</span><span class="p">{},</span> <span class="n">initBindings</span><span class="o">=</span><span class="p">{},</span> <span class="n">queryGraph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">DEBUG</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a SPARQL Update Query against the endpoint,</span>
<span class="sd">        INSERT, LOAD, DELETE etc.</span>
<span class="sd">        Setting initNs adds PREFIX declarations to the beginning of</span>
<span class="sd">        the update. Setting initBindings adds inline VALUEs to the</span>
<span class="sd">        beginning of every WHERE clause. By the SPARQL grammar, all</span>
<span class="sd">        operations that support variables (namely INSERT and DELETE)</span>
<span class="sd">        require a WHERE clause.</span>
<span class="sd">        Important: initBindings fails if the update contains the</span>
<span class="sd">        substring &#39;WHERE {&#39; which does not denote a WHERE clause, e.g.</span>
<span class="sd">        if it is part of a literal.</span>

<span class="sd">        .. admonition:: Context-aware query rewriting</span>

<span class="sd">            - **When:**  If context-awareness is enabled and the graph is not the default graph of the store.</span>
<span class="sd">            - **Why:** To ensure consistency with the :class:`~rdflib.plugins.stores.memory.Memory` store.</span>
<span class="sd">              The graph must accept &quot;local&quot; SPARQL requests (requests with no GRAPH keyword)</span>
<span class="sd">              as if it was the default graph.</span>
<span class="sd">            - **What is done:** These &quot;local&quot; queries are rewritten by this store.</span>
<span class="sd">              The content of each block of a SPARQL Update operation is wrapped in a GRAPH block</span>
<span class="sd">              except if the block is empty.</span>
<span class="sd">              This basically causes INSERT, INSERT DATA, DELETE, DELETE DATA and WHERE to operate</span>
<span class="sd">              only on the context.</span>
<span class="sd">            - **Example:** `&quot;INSERT DATA { &lt;urn:michel&gt; &lt;urn:likes&gt; &lt;urn:pizza&gt; }&quot;` is converted into</span>
<span class="sd">              `&quot;INSERT DATA { GRAPH &lt;urn:graph&gt; { &lt;urn:michel&gt; &lt;urn:likes&gt; &lt;urn:pizza&gt; } }&quot;`.</span>
<span class="sd">            - **Warning:** Queries are presumed to be &quot;local&quot; but this assumption is **not checked**.</span>
<span class="sd">              For instance, if the query already contains GRAPH blocks, the latter will be wrapped in new GRAPH blocks.</span>
<span class="sd">            - **Warning:** A simplified grammar is used that should tolerate</span>
<span class="sd">              extensions of the SPARQL grammar. Still, the process may fail in</span>
<span class="sd">              uncommon situations and produce invalid output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_endpoint</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Update endpoint is not set!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">DEBUG</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inject_prefixes</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">initNs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_contextual</span><span class="p">(</span><span class="n">queryGraph</span><span class="p">):</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_named_graph</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">queryGraph</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initBindings</span><span class="p">:</span>
            <span class="c1"># For INSERT and DELETE the WHERE clause is obligatory</span>
            <span class="c1"># (http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#rModify)</span>
            <span class="c1"># Other query types do not allow variables and don&#39;t</span>
            <span class="c1"># have a WHERE clause.  This also works for updates with</span>
            <span class="c1"># more than one INSERT/DELETE.</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initBindings</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">VALUES ( </span><span class="si">%s</span><span class="s2"> )</span><span class="se">\n</span><span class="s2">{ ( </span><span class="si">%s</span><span class="s2"> ) }</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">),</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span><span class="p">(</span><span class="n">initBindings</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where_pattern</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;WHERE { &quot;</span> <span class="o">+</span> <span class="n">values</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_insert_named_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">query_graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts GRAPH &lt;query_graph&gt; {} into blocks of SPARQL Update operations</span>

<span class="sd">        For instance,  &quot;INSERT DATA { &lt;urn:michel&gt; &lt;urn:likes&gt; &lt;urn:pizza&gt; }&quot;</span>
<span class="sd">        is converted into</span>
<span class="sd">        &quot;INSERT DATA { GRAPH &lt;urn:graph&gt; { &lt;urn:michel&gt; &lt;urn:likes&gt; &lt;urn:pizza&gt; } }&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_graph</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">query_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span><span class="p">(</span><span class="n">query_graph</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">query_graph</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">query_graph</span>
        <span class="n">graph_block_open</span> <span class="o">=</span> <span class="s2">&quot; GRAPH </span><span class="si">%s</span><span class="s2"> {&quot;</span> <span class="o">%</span> <span class="n">query_graph</span>
        <span class="n">graph_block_close</span> <span class="o">=</span> <span class="s2">&quot;} &quot;</span>

        <span class="c1"># SPARQL Update supports the following operations:</span>
        <span class="c1"># LOAD, CLEAR, DROP, ADD, MOVE, COPY, CREATE, INSERT DATA, DELETE DATA, DELETE/INSERT, DELETE WHERE</span>
        <span class="c1"># LOAD, CLEAR, DROP, ADD, MOVE, COPY, CREATE do not make much sense in a context.</span>
        <span class="c1"># INSERT DATA, DELETE DATA, and DELETE WHERE require the contents of their block to be wrapped in a GRAPH &lt;?&gt; { }.</span>
        <span class="c1"># DELETE/INSERT supports the WITH keyword, which sets the graph to be</span>
        <span class="c1"># used for all following DELETE/INSERT instruction including the</span>
        <span class="c1"># non-optional WHERE block. Equivalently, a GRAPH block can be added to</span>
        <span class="c1"># all blocks.</span>
        <span class="c1">#</span>
        <span class="c1"># Strategy employed here: Wrap the contents of every top-level block into a `GRAPH &lt;?&gt; { }`.</span>

        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">modified_query</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLOCK_FINDING_PATTERN</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;block_start&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">modified_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()])</span>
                    <span class="n">modified_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph_block_open</span><span class="p">)</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;block_end&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">since_previous_pos</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span>
                    <span class="k">if</span> <span class="n">modified_query</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">graph_block_open</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">since_previous_pos</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">since_previous_pos</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span>
                    <span class="p">):</span>
                        <span class="c1"># In this case, adding graph_block_start and</span>
                        <span class="c1"># graph_block_end results in an empty GRAPH block. Some</span>
                        <span class="c1"># endpoints (e.g. TDB) can not handle this. Therefore</span>
                        <span class="c1"># remove the previously added block_start.</span>
                        <span class="n">modified_query</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">modified_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">since_previous_pos</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">modified_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">since_previous_pos</span><span class="p">)</span>
                        <span class="n">modified_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph_block_close</span><span class="p">)</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">modified_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">modified_query</span><span class="p">)</span>

<div class="viewcode-block" id="SPARQLUpdateStore.add_graph"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.add_graph">[docs]</a>    <span class="k">def</span> <span class="nf">add_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_aware</span><span class="p">:</span>
            <span class="n">Store</span><span class="o">.</span><span class="n">add_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">graph</span><span class="o">.</span><span class="n">identifier</span> <span class="o">!=</span> <span class="n">DATASET_DEFAULT_GRAPH_ID</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;CREATE GRAPH </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.remove_graph"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.remove_graph">[docs]</a>    <span class="k">def</span> <span class="nf">remove_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_aware</span><span class="p">:</span>
            <span class="n">Store</span><span class="o">.</span><span class="n">remove_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">graph</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="n">DATASET_DEFAULT_GRAPH_ID</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;DROP DEFAULT&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;DROP GRAPH </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_sparql</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.subjects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.subjects">[docs]</a>    <span class="k">def</span> <span class="nf">subjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of subjects with the given predicate and object&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.predicates"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of predicates with the given subject and object&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.objects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.objects">[docs]</a>    <span class="k">def</span> <span class="nf">objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of objects with the given subject and predicate&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.subject_predicates"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.subject_predicates">[docs]</a>    <span class="k">def</span> <span class="nf">subject_predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of (subject, predicate) tuples for the given object&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.subject_objects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.subject_objects">[docs]</a>    <span class="k">def</span> <span class="nf">subject_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of (subject, object) tuples for the given predicate&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="SPARQLUpdateStore.predicate_objects"><a class="viewcode-back" href="../../../../apidocs/rdflib.plugins.stores.html#rdflib.plugins.stores.sparqlstore.SPARQLUpdateStore.predicate_objects">[docs]</a>    <span class="k">def</span> <span class="nf">predicate_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator of (predicate, object) tuples for the given subject&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/RDFlib.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">rdflib 6.2.0-alpha documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rdflib.plugins.stores.sparqlstore</a></li> 
      </ul>
    </div>
<div class="footer">
    &copy; Copyright 2009 - 2021, RDFLib Team.
  Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 4.4.0.
  <br />Theme based on <a href="http://readthedocs.org/">Read The Docs</a>

</div>





  </body>
</html>